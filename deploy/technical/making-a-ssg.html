
<!DOCTYPE html>
<!-- GENERATED -->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="og:title" content="Logan Forman / Dev-Dwarf" />
    <meta property="og:locale" content="en_US" />
    <link rel="canonical" href="http://lcfd.dev/" />
    <meta property="og:url" content="http://lcfd.dev/"/>
    <meta property="og:site_name" content="Logan Forman / Dev-Dwarf" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Stuffed Wombat" />
    <script type="application/ld+json">
      {"@context":"https://schema.org","@type":"WebSite","headline":"Logan Forman / Dev-Dwarf","name":"Logan Forman / Dev-Dwarf","url":"http://lcfd.dev/"}</script>
    <link rel="stylesheet" href="/dwarf.css">
    </head>
    <body>
    <div class="wrapper">
    <main class="page-content" aria-label="Content">

	<title>LCF/DD:Making A Static Site Generator (December 15, 2022)</title>
<br><a href='/writing.html#technical'>back</a><h2>Making A Static Site Generator (December 15, 2022)</h2><hr>
<h2 id='intro'>Introduction</h2><p>
I wanted to make a new portfolio site as I get ready to apply for jobs after I graduate in the Spring (Feel free to <a href='/contact.html'>reach out</a>!). The main options seem to be some engines like WordPress, raw html/css/js, or generators like Jekyll. I respect the engine approach, but generally don't like that sort of thing, and my attempts at raw html always seems to end as a tedious mess. In the past I made a small site following the Jekyll tutorial, but it also felt off to me. There was a lot of setup, many different levels of abstraction that seemed unnecessary, a dizzying array of plugins which weren't quite right, and the result was fairly slow, often taking a noticeable (1-3s) amount of time for my small site.<br><br>I've been working on building my understanding of text-handling in low-level languages like C and C++, so I thought building a small static site generator would be a good test of what I've learned. My goals for the project are:</p>
<ol>
<li> Easily extendable. Do exactly what I want, quickly.</li>
<li> Markdown-like language to write pages/articles in.</li>
<li> Small Codebase. Should be <1000 LOC.</li>

</ol>
<hr>
<h2 id='compile'>Compile Markdown to HTML</h2><p>
I started by making a compiler for a simple markdown language. There is a specification called CommonMark that I <em>think</em> is the canonical version of Markdown, with a reference implementation <a href='https://github.com/commonmark/cmark'>cmark</a>, clocking in at -20,000 LOC. I read through their spec, and while it gave me some ideas, some of it seems like a bit much unless you're expecting to face highly adversarial inputs (like the <a href='https://spec.commonmark.org/0.30/#emphasis-and-strong-emphasis'>17 rules</a> for parsing bold/italic combos). I decided to keep some of the basic syntax of Markdown but not worry about following too closely, making extensions and changes as desired.<br>Taking a hint from the Markdown spec, I implemented my language as a composition of structures:</p>
<pre><code>struct Text {
    Text *next;
    enum Types { 
        NIL = 0,
        TEXT,
        BOLD, ITALIC, STRUCK, CODE_INLINE, 
        LINK, IMAGE, EXPLAIN,
        LIST_ITEM, CODE_BLOCK,
        BREAK,
    } type;
    b32 end;
    str8 text;
};
</code></pre>
<pre><code>struct Block {
    Block *next;
    enum { 
        NIL = 0,
        PARAGRAPH,
        HEADING, RULE, CODE, 
        QUOTE, ORD_LIST, UN_LIST,
    } type;
    u32 num; /* For headings */
    str8 id;
    Str8List content;
    Text* text;
};
</code></pre>
<p>
<code>Blocks</code> represent distinct formatting of seperate sections of the document. <code>Text</code> handles formatting that composes. From the names it's hopefully easy to tell the equivalent html; putting a given tag in one category or the other has been done somewhat arbitrarily. These structures imply parsing the Blocks and then parsing the Text of each block. I decided to parse for Blocks line-by-line, detecting which type of block it is based on the first few characters:</p>
<pre><code>str8_iter_pop_line(str) { /* macro, sets str8 line */
    /* Remove windows newline encoding (\r\n) */
    line = str8_trim_suffix(line, str8_lit("\r"));
    if (line.len == 0) {
       /* Breaks block unless PARAGRAPH or CODE */
    }
    chr8 c[3];
    c[0] = line.str[0];
    c[1] = (line.len > 1)? line.str[1] : 0;
    c[2] = (line.len > 2)? line.str[2] : 0;
    if (c[0] == '`' && c[1] == '`' && c[2] == '`') {    
       /* Start/End Code */
       
    } else if (code_lock) {
        /* Just directly add line if in a code block */
        
    } else if (c[0] == '#') {
        /* Heading */
    
    } else if (c[0] == '>' && c[1] == ' ') {
        /* Quote */
        
    } else if (c[0] >= '1' && c[0] <= '9' && c[1] == '.' && c[2] == ' ') {
        /* Ordered List */
        
    } else if ((c[0] == '*' || c[0] == '-') && c[1] == ' ') {
        /* Un-Ordered List */
    
    } else if (c[0] == '-' && c[1] == '-' && c[2] == '-') {
        /* Horizontal Rule/Line */
        
    } else {
        /* Paragraph */
        
    }
}
<br></code></pre>
<p>
Each of these cases has some additional semantics, such as ending the previous block, parsing out any extra needed information (for example, <code>HEADING</code> counts the number of # characters to determine the size of the heading, and <code>LINK</code> grabs a url), but for the most part they are fairly straight-forward and can be tweaked. The main idea is that each case will either add more Text to the current Block, or end the previous block and start a new one.<br>Each Text node at first has a <code>NIL</code> type, to represent that they are unparsed. After all the blocks are parsed, their Text is parsed as well:</p>
<pre><code>for (curr = root; curr->type != Block::NIL; curr = curr->next) {
    curr->text = parse_text(arena, curr->text);
}
</code></pre>
<p>
The Text parsing is similar to the Block parsing, except each character is checked, and most nodes come in start/end pairs. Because I want to support patterns like <code><b><em>bold-and-italic</em> just-bold</b></code> generating <b><em>bold-and-italic</em> just-bold</b>, its not enough to just have <code>BOLD</code> node encapsulate the bolded text.<br><br></p>
<br><a href='/writing.html#technical'>back</a>
    </main> 
    </div>
    </body>
    <div class="nav">
    <hr>
    <div class="nav-left">
    <nav id="nav-links">
    <a class="nav-link-l" href="/index.html">home</a>
    <a class="nav-link-l" href="/projects.html">projects</a>
    <a class="nav-link-l" href="/writing.html">writing</a>
    <a class="nav-link-l" href="/contact.html">contact</a>
    </nav>
    </div>
    <div class="nav-right">
    <a class="nav-link-r" href="https://github.com/dev-dwarf">github</a>
    <a class="nav-link-r" href="https://twitter.com/dev_dwarf">twitter</a>
    <a class="nav-link-r" href="https://dev-dwarf.itch.io">games</a>
    </div>
    <script>
window.onload = function() { 
    var all_links = document.getElementById("nav-links").getElementsByTagName("a"),
        i=0, len=all_links.length,
        full_path = location.href.split('#')[0]; //Ignore hashes?
    for(; i<len; i++) {
        if(all_links[i].href.split("#")[0] == full_path) {
            all_links[i].className += " current";
        }
    }
}    
    </script>
    </div>
    </html>