
<!DOCTYPE html>
<!-- GENERATED -->
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="og:title" content="Logan Forman / Dev-Dwarf" />
    <meta property="og:locale" content="en_US" />
    <link rel="canonical" href="http://lcfd.dev/" />
    <meta property="og:url" content="http://lcfd.dev/"/>
    <meta property="og:site_name" content="Logan Forman / Dev-Dwarf" />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Stuffed Wombat" />
    <script type="application/ld+json">
      {"@context":"https://schema.org","@type":"WebSite","headline":"Logan Forman / Dev-Dwarf","name":"Logan Forman / Dev-Dwarf","url":"http://lcfd.dev/"}</script>
    <link rel="stylesheet" href="/dwarf.css">
    </head>
    <body>
    <div class="wrapper">
    <main class="page-content" aria-label="Content">

	<title>LCF/DD:Making A Static Site Generator (December 18, 2022)</title>
<br><a href='/writing.html#technical'>back</a><h1>Making A Static Site Generator (December 18, 2022)</h1><hr>
<h2 id='intro'>Introduction</h2><p>
I wanted to make a new portfolio site as I get ready to apply for jobs after I graduate in the Spring (Feel free to <a href='/contact.html'>reach out</a>!). The main options seem to be engines like WordPress, raw HTML/CSS/JS, or generators like Jekyll. The engine approach feels too high-level for me, and my attempts at raw HTML always feel tedious, so I lean towards generators. In the past I made a small site following the Jekyll tutorial, but it felt frustrating to me. There was a lot of setup, many different levels of abstraction that seemed unnecessary, a dizzying array of plugins which weren't quite right, and the result was fairly slow, often taking a noticeable (1-3s) amount of time for my small site.<br><br>I've been working on building my understanding of text-handling in low-level languages like C and C++, so I thought building a small static site generator would be a good test of what I've learned. My goals for the project are:</p>
<ol>
<li> Easily extendable. Do exactly what I want, quickly.</li>
<li> Markdown-like language to write pages/articles in.</li>
<li> Small Codebase. Should be <1000 LOC.</li>

</ol>
<hr>
<h2 id='parse'>Parsing Markdown</h2><p>
I started by making a compiler for a simple markdown language. There is a specification called CommonMark that I <em>think</em> is the canonical version of Markdown, with a reference implementation <a href='https://github.com/commonmark/cmark'>cmark</a>, clocking in at -20,000 LOC. I read through their spec, and while it gave me some ideas, some of it seems like a bit much unless you're expecting to face highly adversarial inputs (like the <a href='https://spec.commonmark.org/0.30/#emphasis-and-strong-emphasis'>17 rules</a> for parsing bold/italic combos). I decided to keep some of the basic syntax of Markdown but not worry about following the spec too closely, making extensions and changes as desired.<br><br>Taking a hint from the Markdown spec, I implemented my language as a composition of <code>Block</code> and <code>Text</code> structures:</p>
<pre><code id=''>/* md_to_html.h */
struct Text {
    Text *next;
    enum Types { 
        NIL = 0,
        TEXT,
        BOLD, ITALIC, STRUCK, CODE_INLINE, 
        LINK, IMAGE, EXPLAIN,
        LIST_ITEM, CODE_BLOCK,
        BREAK,
    } type;
    b32 end;
    str8 text;
};
</code></pre>
<pre><code id=''>struct Block {
    Block *next;
    enum { 
        NIL = 0,
        PARAGRAPH,
        HEADING, RULE, CODE, 
        QUOTE, ORD_LIST, UN_LIST,
    } type;
    u32 num; /* For headings */
    str8 id;
    Str8List content;
    Text* text;
};
</code></pre>
<p>
<code>Blocks</code> represent distinct formatting of seperate sections of the document. <code>Text</code> handles formatting that composes. From the names it's hopefully easy to tell the equivalent HTML; putting a given tag in one category or the other has been done somewhat arbitrarily. These structures imply parsing the Blocks and then parsing the Text of each block. I decided to parse for Blocks line-by-line, detecting which type of block it is based on the first few characters:</p>
<pre><code id=''>/* md_to_html.cpp */
str8_iter_pop_line(str) { /* macro, sets str8 line */
    /* Remove windows newline encoding (\r\n) */
    line = str8_trim_suffix(line, str8_lit("\r"));
    if (line.len == 0) {
       /* Breaks block unless PARAGRAPH or CODE */
    }
    chr8 c[3];
    c[0] = line.str[0];
    c[1] = (line.len > 1)? line.str[1] : 0;
    c[2] = (line.len > 2)? line.str[2] : 0;
    if (c[0] == '`' && c[1] == '`' && c[2] == '`') {    
       /* Start/End Code */
       
    } else if (code_lock) {
        /* Just directly add line if in a code block */
        
    } else if (c[0] == '#') {
        /* Heading */
    
    } else if (c[0] == '>' && c[1] == ' ') {
        /* Quote */
        
    } else if (c[0] >= '1' && c[0] <= '9' && c[1] == '.' && c[2] == ' ') {
        /* Ordered List */
        
    } else if ((c[0] == '*' || c[0] == '-') && c[1] == ' ') {
        /* Un-Ordered List */
    
    } else if (c[0] == '-' && c[1] == '-' && c[2] == '-') {
        /* Horizontal Rule/Line */
        
    } else {
        /* Paragraph */
    }
}
<br></code></pre>
<p>
Each of these cases has some additional semantics, such as ending the previous block, parsing out any extra needed information (for example, <code>HEADING</code> counts the number of # characters to determine the size of the heading, and <code>LINK</code> needs to grab the url), but for the most part they are fairly straight-forward and can be tweaked. The main idea is that each case will either add more Text to the current Block, or end the previous block and start a new one.<br><br>Each Text node at first has a <code>NIL</code> type, to represent that they are unparsed. After all the blocks are parsed, their Text is parsed as well:</p>
<pre><code id=''>for (curr = root; curr->type != Block::NIL; curr = curr->next) {
    curr->text = parse_text(arena, curr->text);
}
</code></pre>
<p>
The Text parsing is similar to the Block parsing, except each character is checked, and most nodes come in start/end pairs. Because I want to support composing formatting like <code>***bold-and-italic* just-bold**</code> generating <b><em>bold-and-italic</em> just-bold</b>, its not enough to just have <code>BOLD</code> node encapsulate the bolded text in a pair of tags. For this reason each text node has an <code>end</code> flag marking it as the start or end node of a pair:</p>
<pre><code id=''>for (; curr->next != 0; pre = curr, curr = curr->next) {
    str8 s = curr->text;
    if ((curr->type == Text::LIST_ITEM) /* Already formatted, do not parse */
        || (curr->type == Text::CODE_BLOCK)
        || (curr->type == Text::BREAK)) {
        continue;
    }
    if (curr->type == Text::NIL) {
        curr->type = Text::TEXT;
    }
    if (s.len == 0) {
        if (curr->type == Text::TEXT) {
            curr->type = Text::BREAK;
        } else {
            PUSH_TEXT(Text::BREAK, 0, 1);
        }
        continue;
    }
    chr8 c[3]; 
    c[1] = s.str[0];
    c[2] = (s.len > 1)? s.str[1] : 0;
    str8_iter_custom(s, i, _unused) {
        c[0] = c[1];
        c[1] = c[2];
        c[2] = (s.len > i+2)? s.str[i+2] : 0;
        if (ignore_next) {
            PUSH_TEXT(Text::TEXT, i-1, 1);
            ignore_next = false;
        } else if (c[0] == '`') {
            /* Inline Code */
            
        } else if (curr->type == Text::CODE_INLINE && !curr->end) {
            /* Do nothing, do not parse stuff inside code */
        } else if (c[0] == '*' && c[1] == '*') {
            /* Bold *.
            
        } else if (c[0] == '*') {
            /* Italic */
            
        } else if (c[0] == '~' && c[1] == '~') {
            /* Strikethrough */
            
        } else if (c[0] == '@' && c[1] == '(') {
            /* Links */
            
        } else if (c[0] == '!' && c[1] == '(') {
            /* Images */
            
        } else if (c[0] == '?' && c[1] == '(') {
            /* Explain - Hover over to see expanded text */
            
        } else if (c[0] == ')') {
            /* Closing parenthesis can end one of the above ^ */
            if (paren_stacki > 0) {
                Text::Types t = paren_stack[--paren_stacki];
                PUSH_TEXT(t, i, 1);
            }
            break;
        } else if (c[0] == '\\') {
            /* Backslash ignores next formatting char */
        }
    } /* end str8_iter */
    ASSERTM(pre == &pre_filler || pre->type != Text::NIL, "Must not leave NIL nodes in Text linked-list!");
}
</code></pre>
<p>
I have been leaving out the details inside the if statements in the parsing, but you can see the full details <a href='https://github.com/dev-dwarf/dev-dwarf.github.io/blob/main/static-site-gen/md_to_html.cpp'>here</a>. The insides are mostly just small amounts of parsing text and then some macros for pushing new <code>Block</code> or <code>Text</code> nodes onto linked lists. You might notice in the above parsing some departures from Markdown, such as <code>@(link text)</code> to notate a link, instead of a <code>[text](link)</code> pair.</p>
<hr>
<h2 id='compile'>Render as HTML</h2><p>
As a basic example of what we have so far, parsing the following:</p>
<pre><code id=''>## Hello
It's nice to be **loud**!
</code></pre>
<p>
Will give this structure:</p>
<pre><code id=''>Block(type=Header, num=2, text=[
    Text(type=Text, str="Hello")
]),
Block(type=Paragraph, text=[
    Text(type=Text, str="It's nice to be "),
    Text(type=Bold, str="loud", end=false),
    Text(type=Bold, str="!", end=true)
])
</code></pre>
<p>
The desired HTML is something like:</p>
<pre><code id='html'><h2>Hello</h2>
<p>It's nice to be <b>loud</b>!</p>
</code></pre>
<p>
With the above as the goal, its not hard to imagine rendering the parsed nodes to HTML using a couple loops:</p>
<pre><code id=''>Str8List render(Arena* arena, Block* root) {
    Str8List out = {0};
    for (Block* b = root; b->type != Block::NIL; b = b->next) {
        switch (b->type) {
            /* Do pre-content tags for Block type. EX: */
            case Block::ORD_LIST: {
                Str8List_add(arena, &out, str8_lit("&ltol&gt\n"));
            } break;
        }
    
        b->content = render_text(arena, b->text);
        Str8List_append(&out, Str8List_copy(arena, b->content));    
    
        switch (b->type) {
            /* Do post-content tags for Block type. EX: */
            case Block::ORD_LIST: {
                Str8List_add(arena, &out, str8_lit("\n&lt/ol&gt\n"));
            } break;                    
        }
    }
    return out;
}
</code></pre>
<pre><code id=''>Str8List render_text(Arena* arena, Text* root) {
    Str8List out = {0};
    Text prev_filler = {root, Text::NIL, 0};
    for (Text* t = root, *prev = &prev_filler; t->type != Text::NIL; prev = t, t = t->next) {
        switch (t->type) {
            /* Add start or end tags based on t->end. EX: */
            case Text::BOLD: {
                str8 s[2] = {str8_lit("&ltb&gt"), str8_lit("&lt/b&gt")};
                Str8List_add(arena, &out, s[t->end]);
                Str8List_add(arena, &out, t->text);
            } break;
        }
    }
    return out;
}
</code></pre>
<hr>
<h2 id='generate'>Generating the site.</h2><p>
The Markdown compiler is a good step, but it needs to be told what to compile, and the results are still missing necessary HTML boilerplate. For my site I decided to have a <code>src</code> folder for the markdown contents of my articles, and then compile everything to a <code>deploy</code> folder containing the generated HTML and other assets:</p>
<pre><code id=''>- dev-dwarf.github.io
    - src
        foo.md
        etc...
    - deploy
        foo.html
        etc...
</code></pre>
<p>
I started a new file to drive this process. First I defined some structs to store data for each page, and help me manage lists of pages:</p>
<pre><code id=''>/* site.h */
struct Page {
    Page *next; 
    str8 filename;
    str8 base_href;
    Str8List base_dir;
    u64 created_time;
    u64 modified_time;
    str8 title;
    str8 content;
    enum Types {
        DEFAULT,
        /* don't worry about the other types for now */
    } type;
};
struct PageList {
    Page *first;
    Page *last;
    u64 count;
};
</code></pre>
<p>
Then there is a main loop that goes something like:</p>
<pre><code id=''>global Str8List dir;
int main() {
    Arena *longa = Arena_create_default();
    Arena *tempa = Arena_create_default();
<br>    /* ... set dir to src directory */
    
    PageList allPages = get_pages_in_dir(longa, Page::DEFAULT);
<br>    for (Page *n = allPages.first; n != 0; n = n->next) {
        compile_page(longa, tempa, n);
        Arena_reset_all(tempa);
    }
}
</code></pre>
<p>
The <code>global Str8List dir</code> holds the current directory/file. It's convenient to have it as a list so that I can pop off or switch out nodes to change the targeted file or directory. <code>get_pages_in_dir</code> just uses filesystem calls to make a list of markdown files in the <code>src</code> folder. <code>compile_page</code> loads the raw markdown, compiles it, and adds some enclosing HTML to the front and back. Finally it's written out to the equivalent HTML file in the <code>deploy</code> folder:</p>
<pre><code id=''>void compile_page(Arena *longa, Arena *tempa, Page *page) {
    Str8List_append(&dir, page->base_dir);
        
    filename.str = page->filename;
    Str8List_add_node(&dir, &filename);
    switch_to_dir(&src);
    page->content = win32_load_entire_file(tempa, build_dir(tempa));
    Str8List_pop_node(&dir);
<br>    filename.str = str8_concat(tempa, str8_cut(page->filename, 3), str8_lit("html\0"));
    Str8List_add_node(&dir, &filename);
<br>    Str8List html = {0};
    Str8List_add(tempa, &html, HEADER);
    Str8List_add(tempa, &html, str8_lit("\t<title>LCF/DD:"));
    Str8List_add(tempa, &html, page->title);
    Str8List_add(tempa, &html, str8_lit("</title>\n"));
<br>    Block* blocks = parse(tempa, page->content);
    Str8List md = render(tempa, blocks);
    Str8List_append(&html, md);
    
    Str8List_add(tempa, &html, FOOTER);
<br>    switch_to_dir(&deploy);
    win32_write_file(build_dir(tempa).str, html);
<br>    page->content = str8_EMPTY; /* clear this because it was on the temp arena */
    Str8List_pop_node(&dir);
    Str8List_pop(&dir, page->base_dir.count);
}
</code></pre>
<p>
And that's pretty much it for a heavily-idealized version of my static site generator! The actual thing can be found <a href='https://github.com/dev-dwarf/dev-dwarf.github.io'>on GitHub</a>. You may have noticed an unused type field for pages; the real version of the generator has <code>ARTICLE</code> pages and and <code>INDEX</code> page. <code>ARTICLE</code>s have slightly different HTML generated, and the <code>INDEX</code> gets a list of links to articles appended to it. I don't think its worth writing about these yet as they are very hacked in and I want to change that system soon! However I am pleased with how easy it is to quickly hack in features like those given what I have described here as a base.</p>
<hr>
<h2 id='conc'>Conclusion</h2><p>
Overall I'm pretty happy with the results of this project so far. The up-front time investment was a bit more than using Jekyll (about 4-days of hacking and writing), but for it I have a small, fast, and extendable static site generator tailored to my needs.<br><br>I already hacked in some basic features to write this article, but I'd like to rework these soon. In addition, there's quite a few things I'd like to add:</p>
<ol>
<li> Generate an index/section list for articles.</li>
<li> Generate an RSS feed from recent articles.</li>
<li> After the first compile of each page, run in the background checking for changes and compile files automatically. Right now I manually run <code>site.exe</code> to see my changes each time, but it would help my flow if that was taken care of for me.</li>
<li> Introduce some sort of templating/custom generation for individual pages. I <b>abhor</b> how most generators handle this sort of feature so I'm excited to look for a unique approach. I'd prefer something where I can easily hack in new templates in C++ instead of using some bogus templating language.</li>
<li> Additional miscellanous features like captions for images, subsections, and asides/expandable text. </li>

</ol>
<p>
I should also mention that although the source code for the markdown compiler and my site are on github, they can't be run as is without lcf, my <a href='http://nothings.org/stb.h'>stb</a>-esque standard library. I've only fairly recently started my library and I tend to make tweaks and additions almost everytime I work on a project right now, so I don't feel comfortable having it out there as a public repo. If you really want a copy so you can compile my site yourself <a href='/contact.html'>send me a message</a>.</p>
<br><a href='/writing.html#technical'>back</a>
    </main> 
    </div>
    </body>
    <div class="nav">
    <hr>
    <div class="nav-left">
    <nav id="nav-links">
    <a class="nav-link-l" href="/index.html">home</a>
    <a class="nav-link-l" href="/projects.html">projects</a>
    <a class="nav-link-l" href="/writing.html">writing</a>
    <a class="nav-link-l" href="/contact.html">contact</a>
    </nav>
    </div>
    <div class="nav-right">
    <a class="nav-link-r" href="https://github.com/dev-dwarf">github</a>
    <a class="nav-link-r" href="https://twitter.com/dev_dwarf">twitter</a>
    <a class="nav-link-r" href="https://dev-dwarf.itch.io">games</a>
    </div>
    <script>
window.onload = function() { 
    full_path = location.href.split('#')[0];
    Array.from(document.getElementById("nav-links").getElementsByTagName("a"))
        .filter(l => l.href.split("#")[0] == full_path)
        .forEach(l => l.className += " current");
    Array.from(document.getElementsByTagName("code"))
        .filter(el => el.id == "html")  
        .forEach(el => el.innerText = el.innerHTML);
}    
    </script>
    </div>
    </html>