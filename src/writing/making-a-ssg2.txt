@{article}
@{title, Upgrading A Static Site Generator, 09 Jun 2022}
@{desc, It's been a while! See how I've upgraded the site with the 'special' node.}
@{sections}
---
##introd Introduction
It's been a while since my first post, but I'm going to try to make posts more consistently now that I have graduated. A good way to start would be walking through the rest of my site generator. When I left off @(/writing/making-a-ssg1.html last time), the main thing missing from my site was a way to handle special elements, like an index for articles on the @(/writing.html writing page).


In this post I'll walk through how adding one simple feature to my markdown parser lets me handle these cases in my site specific code easily. In most static site generators I see special cases like this implemented using a templating language (Jekyll, for example, suggests @(https://shopify.github.io/liquid/ Liquid)). In my experience these templates end up scattered around the code, and adding yet another underpowered language to the already overpopulated web-dev stack is annoying. My approach lets templates be made in C just like the rest of my site generator, with full access to all the existing data structures for the website pages.

##special The Special Block
So instead of writing an interpreter for some crappy template language, here's how the markdown compiler has been updated to handle special templates (`md_to_html.cpp`):
```
/* in parse()... */
} else if (c[0] == '@' && c[1] == '{') {
PUSH_BLOCK(); /* Immediately end the previous block. */
line = str_skip(line, 2);
/* Mark this block as special, save first arg as .id */
next.type = Block::SPECIAL;
next.id = str_pop_at_first_delimiter(&line, strl(",}"));
/* Push remaining args to .content */
str_iter_pop_delimiter(line, strl(",}")) {
    /* NOTE(lcf): optionally allow space in args list */
    if (str_char_location(sub, ' ') == 0) {
        sub = str_skip(sub, 1);
    }
    StrList_push(arena, &next.content, sub);
}
/* End the special block */
PUSH_BLOCK();
}
```
That's it. There's no additional rendering code or anything else in the markdown compiler, it just packages up arguments into the Block data structure and then is done. All the remaining work of handling the special templates is in the site specific code (`site.cpp`).

So now in `site.cpp:compile_page()`, instead of:
```
/* ... snip ... */
Block* blocks = parse(tempa, page->content);
StrList md = {0};
for (Block* b = blocks; b->type != Block::NIL; b = b->next) {
    md = render_block(tempa, b);
    StrList_append(&html, md);
}
/* ... snip ... */
```

I now have:
```
Block* blocks = parse(tempa, page->content);
StrList md = {0};
for (Block* b = blocks; b->type != Block::NIL; b = b->next) {
    if (b->type != Block::SPECIAL) {
        md = render_block(tempa, b);
        StrList_append(&html, md);
    } else {
        render_special_block(longa, tempa, page, &html, &back, blocks, b);
    }
}
```
Where `render_special_block()` contains the code to handle each special node.

##examples Example Special Blocks



##other Other Updates



##conc Conclusion
