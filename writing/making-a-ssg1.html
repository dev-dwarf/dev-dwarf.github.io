<!DOCTYPE html>
<!-- GENERATED -->
<html lang='en-US'>
<head>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1.0'>
<meta property='og:title' content='Logan Forman' />
<meta property='og:locale' content='en_US' />
<meta property='og:image' content='/assets/dd.png' />
<link rel='canonical' href='http://loganforman.com/' />
<meta property='og:url' content='http://loganforman.com/'/>
<meta property='og:site_name' content='Logan Forman / Dev-Dwarf' />
<meta property='og:type' content='website' />
<meta name='twitter:card' content='summary' />
<meta property='twitter:title' content='Logan Forman' />
<script type='application/ld+json'>
{'@context':'https://schema.org','@type':'WebSite','headline':'Logan Forman / Dev-Dwarf','name':'Logan Forman / Dev-Dwarf','url':'http://loganforman.com/'}</script>
<link rel='stylesheet' href='/dwarf.css'>
<link rel='icon' type='image/x-icon' href='/assets/favicon.ico'>
</head>
<body>
<script>
var theme = localStorage.getItem('theme') || 'light'
document.querySelector('body').setAttribute('data-theme', theme)
function toggleNight() {
console.log('toggle')
theme = (theme == 'light')? 'night' : 'light'
localStorage.setItem('theme', theme)
document.querySelector('body').setAttribute('data-theme', theme);  
}
</script>
<div class='wrapper'>
<main class='page-content' aria-label='Content'>
	<title>Making A Static Site Generator</title>

<div style='clear: both'><h1>Making A Static Site Generator</h1><h3>18 Dec 2022</h3></div>
<ul class='sections'>
<li><a href='#introd'> Introduction</a></li>
<li><a href='#parse'> Parsing Markdown</a></li>
<li><a href='#compile'> Render as HTML</a></li>
<li><a href='#generate'> Generating the Site</a></li>
<li><a href='#conc'> Conclusion</a></li>
</ul>
<hr>

<h2 id='introd'>
 Introduction
</h2>
<p>
I wanted to make a new portfolio site as I get ready to apply for jobs after I graduate in the Spring. The main options seem to be engines like WordPress, raw HTML/CSS/JS, or generators like Jekyll. The engine approach feels too high-level for me, and my attempts at raw HTML always feel tedious, so I lean towards generators. In the past I made a small site following the Jekyll tutorial, but it felt frustrating to me. There was a lot of setup, many different levels of abstraction that seemed unnecessary, a dizzying array of plugins which weren't quite right, and the result was fairly slow, often taking a noticeable (1-3s) amount of time for my small site.
</p>
<p>
I've been working on building my understanding of text-handling in low-level languages like C and C++, so I thought building a small static site generator would be a good test of what I've learned. My goals for the project are:
</p>
<ol>
<li> Easily extendable. Do exactly what I want, quickly.</li>
<li> Markup language to write pages/articles in.</li>
<li> Small. Should be <1000 LOC.</li>
</ol>
<hr>

<h2 id='parse'>
 Parsing Markdown
</h2>
<p>
I started by making a compiler for a simple markup language. <em>Markdown</em> is probably the most popular markup language on the web today. There is a specification called CommonMark that I <em>think</em> is the canonical version of Markdown, with a reference implementation <a href='https://github.com/commonmark/cmark'>cmark</a>, clocking in at ~20,000 LOC. I read through their spec, and while it gave me some ideas, some of it seems like a bit much unless you're expecting to face highly adversarial inputs (like the <a href='https://spec.commonmark.org/0.30/#emphasis-and-strong-emphasis'>17 rules</a> for parsing bold/italic combos). I decided to keep some of the basic syntax of Markdown but not worry about following the spec too closely, making extensions and changes as desired.
</p>
<p>
Taking a hint from the Markdown spec, I implemented my language as a composition of <code>Block</code> and <code>Text</code> structures:
</p>
<code id='code000'><pre>
<span id='code000-1'><a href='#code000-1' aria-hidden='true'></a><span style='color: var(--comment);'>/* md_to_html.h */</span></span><span id='code000-2'><a href='#code000-2' aria-hidden='true'></a>struct Text {</span><span id='code000-3'><a href='#code000-3' aria-hidden='true'></a>    Text *next;</span><span id='code000-4'><a href='#code000-4' aria-hidden='true'></a>    enum Types { </span><span id='code000-5'><a href='#code000-5' aria-hidden='true'></a>        NIL = 0,</span><span id='code000-6'><a href='#code000-6' aria-hidden='true'></a>        TEXT,</span><span id='code000-7'><a href='#code000-7' aria-hidden='true'></a>        BOLD, ITALIC, STRUCK, CODE_INLINE, </span><span id='code000-8'><a href='#code000-8' aria-hidden='true'></a>        LINK, IMAGE, EXPLAIN,</span><span id='code000-9'><a href='#code000-9' aria-hidden='true'></a>        LIST_ITEM, CODE_BLOCK,</span><span id='code000-10'><a href='#code000-10' aria-hidden='true'></a>        BREAK,</span><span id='code000-11'><a href='#code000-11' aria-hidden='true'></a>    } type;</span><span id='code000-12'><a href='#code000-12' aria-hidden='true'></a>    b32 end;</span><span id='code000-13'><a href='#code000-13' aria-hidden='true'></a>    str text;</span><span id='code000-14'><a href='#code000-14' aria-hidden='true'></a>};</span><span id='code000-15'><a href='#code000-15' aria-hidden='true'></a></span><span id='code000-16'><a href='#code000-16' aria-hidden='true'></a>struct Block {</span><span id='code000-17'><a href='#code000-17' aria-hidden='true'></a>    Block *next;</span><span id='code000-18'><a href='#code000-18' aria-hidden='true'></a>    enum { </span><span id='code000-19'><a href='#code000-19' aria-hidden='true'></a>        NIL = 0,</span><span id='code000-20'><a href='#code000-20' aria-hidden='true'></a>        PARAGRAPH,</span><span id='code000-21'><a href='#code000-21' aria-hidden='true'></a>        HEADING, RULE, CODE, </span><span id='code000-22'><a href='#code000-22' aria-hidden='true'></a>        QUOTE, ORD_LIST, UN_LIST,</span><span id='code000-23'><a href='#code000-23' aria-hidden='true'></a>    } type;</span><span id='code000-24'><a href='#code000-24' aria-hidden='true'></a>    u32 num; <span style='color: var(--comment);'>/* For headings */</span></span><span id='code000-25'><a href='#code000-25' aria-hidden='true'></a>    str id;</span><span id='code000-26'><a href='#code000-26' aria-hidden='true'></a>    StrList content;</span><span id='code000-27'><a href='#code000-27' aria-hidden='true'></a>    Text* text;</span><span id='code000-28'><a href='#code000-28' aria-hidden='true'></a>};</span></pre></code>
<p>
<code>Blocks</code> represent distinct formatting of seperate sections of the document. <code>Text</code> handles formatting that composes. From the names it's hopefully easy to tell the equivalent HTML; putting a given tag in one category or the other has been done somewhat arbitrarily. These structures imply parsing the Blocks and then parsing the Text of each block. I decided to parse for Blocks line-by-line, detecting which type of block it is based on the first few characters:
</p>
<code id='code001'><pre>
<span id='code001-1'><a href='#code001-1' aria-hidden='true'></a><span style='color: var(--comment);'>/* md_to_html.cpp */</span></span><span id='code001-2'><a href='#code001-2' aria-hidden='true'></a>str_iter_pop_line(str) { </span><span id='code001-3'><a href='#code001-3' aria-hidden='true'></a>    <span style='color: var(--comment);'>/* Remove windows newline encoding (\r\n) */</span></span><span id='code001-4'><a href='#code001-4' aria-hidden='true'></a>    line = str_trim_suffix(line, strl(<span style='color: var(--red);'>"\r"</span>));</span><span id='code001-5'><a href='#code001-5' aria-hidden='true'></a>    if (line.len == 0) {</span><span id='code001-6'><a href='#code001-6' aria-hidden='true'></a>       <span style='color: var(--comment);'>/* Breaks block unless PARAGRAPH or CODE */</span></span><span id='code001-7'><a href='#code001-7' aria-hidden='true'></a>    }</span><span id='code001-8'><a href='#code001-8' aria-hidden='true'></a>    ch8 c[3];</span><span id='code001-9'><a href='#code001-9' aria-hidden='true'></a>    c[0] = line.str[0];</span><span id='code001-10'><a href='#code001-10' aria-hidden='true'></a>    c[1] = (line.len &gt; 1)? line.str[1] : 0;</span><span id='code001-11'><a href='#code001-11' aria-hidden='true'></a>    c[2] = (line.len &gt; 2)? line.str[2] : 0;</span><span id='code001-12'><a href='#code001-12' aria-hidden='true'></a>    if (c[0] == <span style='color: var(--red);'>'`'</span> &amp;&amp; c[1] == <span style='color: var(--red);'>'`'</span> &amp;&amp; c[2] == <span style='color: var(--red);'>'`'</span>) {    </span><span id='code001-13'><a href='#code001-13' aria-hidden='true'></a>       <span style='color: var(--comment);'>/* Start/End Code */</span></span><span id='code001-14'><a href='#code001-14' aria-hidden='true'></a>       </span><span id='code001-15'><a href='#code001-15' aria-hidden='true'></a>    } else if (code_lock) {</span><span id='code001-16'><a href='#code001-16' aria-hidden='true'></a>        <span style='color: var(--comment);'>/* Just directly add line if in a code block */</span></span><span id='code001-17'><a href='#code001-17' aria-hidden='true'></a>        </span><span id='code001-18'><a href='#code001-18' aria-hidden='true'></a>    } else if (c[0] == <span style='color: var(--red);'>'#'</span>) {</span><span id='code001-19'><a href='#code001-19' aria-hidden='true'></a>        <span style='color: var(--comment);'>/* Heading */</span></span><span id='code001-20'><a href='#code001-20' aria-hidden='true'></a>    </span><span id='code001-21'><a href='#code001-21' aria-hidden='true'></a>    } else if (c[0] == <span style='color: var(--red);'>'&gt;'</span> &amp;&amp; c[1] == <span style='color: var(--red);'>' '</span>) {</span><span id='code001-22'><a href='#code001-22' aria-hidden='true'></a>        <span style='color: var(--comment);'>/* Quote */</span></span><span id='code001-23'><a href='#code001-23' aria-hidden='true'></a>        </span><span id='code001-24'><a href='#code001-24' aria-hidden='true'></a>    } else if (c[0] &gt;= <span style='color: var(--red);'>'1'</span> &amp;&amp; c[0] &lt;= <span style='color: var(--red);'>'9'</span> &amp;&amp; c[1] == <span style='color: var(--red);'>'.'</span> &amp;&amp; c[2] == <span style='color: var(--red);'>' '</span>) {</span><span id='code001-25'><a href='#code001-25' aria-hidden='true'></a>        <span style='color: var(--comment);'>/* Ordered List */</span></span><span id='code001-26'><a href='#code001-26' aria-hidden='true'></a>        </span><span id='code001-27'><a href='#code001-27' aria-hidden='true'></a>    } else if ((c[0] == <span style='color: var(--red);'>'*'</span> || c[0] == <span style='color: var(--red);'>'-'</span>) &amp;&amp; c[1] == <span style='color: var(--red);'>' '</span>) {</span><span id='code001-28'><a href='#code001-28' aria-hidden='true'></a>        <span style='color: var(--comment);'>/* Un-Ordered List */</span></span><span id='code001-29'><a href='#code001-29' aria-hidden='true'></a>    </span><span id='code001-30'><a href='#code001-30' aria-hidden='true'></a>    } else if (c[0] == <span style='color: var(--red);'>'-'</span> &amp;&amp; c[1] == <span style='color: var(--red);'>'-'</span> &amp;&amp; c[2] == <span style='color: var(--red);'>'-'</span>) {</span><span id='code001-31'><a href='#code001-31' aria-hidden='true'></a>        <span style='color: var(--comment);'>/* Horizontal Rule/Line */</span></span><span id='code001-32'><a href='#code001-32' aria-hidden='true'></a>        </span><span id='code001-33'><a href='#code001-33' aria-hidden='true'></a>    } else {</span><span id='code001-34'><a href='#code001-34' aria-hidden='true'></a>        <span style='color: var(--comment);'>/* Paragraph */</span></span><span id='code001-35'><a href='#code001-35' aria-hidden='true'></a>    }</span><span id='code001-36'><a href='#code001-36' aria-hidden='true'></a>}</span><span id='code001-37'><a href='#code001-37' aria-hidden='true'></a></span></pre></code>
<p>
Each of these cases has some additional semantics, such as ending the previous block, parsing out any extra needed information (for example, <code>HEADING</code> counts the number of # characters to determine the size of the heading, and <code>LINK</code> needs to grab the url), but for the most part they are fairly straight-forward and can be tweaked. The main idea is that each case will either add more Text to the current Block, or end the previous block and start a new one.
</p>
<p>
Each Text node at first has a <code>NIL</code> type, to represent that they are unparsed. After all the blocks are parsed, their Text is parsed as well:
</p>
<code id='code002'><pre>
<span id='code002-1'><a href='#code002-1' aria-hidden='true'></a>for (curr = root; curr-&gt;type != Block::NIL; curr = curr-&gt;next) {</span><span id='code002-2'><a href='#code002-2' aria-hidden='true'></a>    curr-&gt;text = parse_text(arena, curr-&gt;text);</span><span id='code002-3'><a href='#code002-3' aria-hidden='true'></a>}</span></pre></code>
<p>
The Text parsing is similar to the Block parsing, except each character is checked, and most nodes come in start/end pairs. Because I want to support composing formatting like <code><b><em>bold-and-italic</em> just-bold</b></code> generating <b><em>bold-and-italic</em> just-bold</b>, it's not enough to just have <code>BOLD</code> node encapsulate the bolded text in a pair of tags. For this reason each text node has an <code>end</code> flag marking it as the start or end node of a pair:
</p>
<code id='code003'><pre>
<span id='code003-1'><a href='#code003-1' aria-hidden='true'></a>for (; curr-&gt;next != 0; pre = curr, curr = curr-&gt;next) {</span><span id='code003-2'><a href='#code003-2' aria-hidden='true'></a>    str s = curr-&gt;text;</span><span id='code003-3'><a href='#code003-3' aria-hidden='true'></a>    if ((curr-&gt;type == Text::LIST_ITEM) <span style='color: var(--comment);'>/* Already formatted, do not parse */</span></span><span id='code003-4'><a href='#code003-4' aria-hidden='true'></a>        || (curr-&gt;type == Text::CODE_BLOCK)</span><span id='code003-5'><a href='#code003-5' aria-hidden='true'></a>        || (curr-&gt;type == Text::BREAK)) {</span><span id='code003-6'><a href='#code003-6' aria-hidden='true'></a>        continue;</span><span id='code003-7'><a href='#code003-7' aria-hidden='true'></a>    }</span><span id='code003-8'><a href='#code003-8' aria-hidden='true'></a>    if (curr-&gt;type == Text::NIL) {</span><span id='code003-9'><a href='#code003-9' aria-hidden='true'></a>        curr-&gt;type = Text::TEXT;</span><span id='code003-10'><a href='#code003-10' aria-hidden='true'></a>    }</span><span id='code003-11'><a href='#code003-11' aria-hidden='true'></a>    if (s.len == 0) {</span><span id='code003-12'><a href='#code003-12' aria-hidden='true'></a>        if (curr-&gt;type == Text::TEXT) {</span><span id='code003-13'><a href='#code003-13' aria-hidden='true'></a>            curr-&gt;type = Text::BREAK;</span><span id='code003-14'><a href='#code003-14' aria-hidden='true'></a>        } else {</span><span id='code003-15'><a href='#code003-15' aria-hidden='true'></a>            PUSH_TEXT(Text::BREAK, 0, 1);</span><span id='code003-16'><a href='#code003-16' aria-hidden='true'></a>        }</span><span id='code003-17'><a href='#code003-17' aria-hidden='true'></a>        continue;</span><span id='code003-18'><a href='#code003-18' aria-hidden='true'></a>    }</span><span id='code003-19'><a href='#code003-19' aria-hidden='true'></a>    chr8 c[3]; </span><span id='code003-20'><a href='#code003-20' aria-hidden='true'></a>    c[1] = s.str[0];</span><span id='code003-21'><a href='#code003-21' aria-hidden='true'></a>    c[2] = (s.len &gt; 1)? s.str[1] : 0;</span><span id='code003-22'><a href='#code003-22' aria-hidden='true'></a>    str_iter_custom(s, i, _unused) {</span><span id='code003-23'><a href='#code003-23' aria-hidden='true'></a>        c[0] = c[1];</span><span id='code003-24'><a href='#code003-24' aria-hidden='true'></a>        c[1] = c[2];</span><span id='code003-25'><a href='#code003-25' aria-hidden='true'></a>        c[2] = (s.len &gt; i+2)? s.str[i+2] : 0;</span><span id='code003-26'><a href='#code003-26' aria-hidden='true'></a>        if (ignore_next) {</span><span id='code003-27'><a href='#code003-27' aria-hidden='true'></a>            PUSH_TEXT(Text::TEXT, i-1, 1);</span><span id='code003-28'><a href='#code003-28' aria-hidden='true'></a>            ignore_next = false;</span><span id='code003-29'><a href='#code003-29' aria-hidden='true'></a>        } else if (c[0] == <span style='color: var(--red);'>'`'</span>) {</span><span id='code003-30'><a href='#code003-30' aria-hidden='true'></a>            <span style='color: var(--comment);'>/* Inline Code */</span></span><span id='code003-31'><a href='#code003-31' aria-hidden='true'></a>            </span><span id='code003-32'><a href='#code003-32' aria-hidden='true'></a>        } else if (curr-&gt;type == Text::CODE_INLINE &amp;&amp; !curr-&gt;end) {</span><span id='code003-33'><a href='#code003-33' aria-hidden='true'></a>            <span style='color: var(--comment);'>/* Do nothing, do not parse stuff inside code */</span></span><span id='code003-34'><a href='#code003-34' aria-hidden='true'></a>        } else if (c[0] == <span style='color: var(--red);'>'*'</span> &amp;&amp; c[1] == <span style='color: var(--red);'>'*'</span>) {</span><span id='code003-35'><a href='#code003-35' aria-hidden='true'></a>            <span style='color: var(--comment);'>/* Bold */</span></span><span id='code003-36'><a href='#code003-36' aria-hidden='true'></a>            </span><span id='code003-37'><a href='#code003-37' aria-hidden='true'></a>        } else if (c[0] == <span style='color: var(--red);'>'*'</span>) {</span><span id='code003-38'><a href='#code003-38' aria-hidden='true'></a>            <span style='color: var(--comment);'>/* Italic */</span></span><span id='code003-39'><a href='#code003-39' aria-hidden='true'></a>            </span><span id='code003-40'><a href='#code003-40' aria-hidden='true'></a>        } else if (c[0] == <span style='color: var(--red);'>'~'</span> &amp;&amp; c[1] == <span style='color: var(--red);'>'~'</span>) {</span><span id='code003-41'><a href='#code003-41' aria-hidden='true'></a>            <span style='color: var(--comment);'>/* Strikethrough */</span></span><span id='code003-42'><a href='#code003-42' aria-hidden='true'></a>            </span><span id='code003-43'><a href='#code003-43' aria-hidden='true'></a>        } else if (c[0] == <span style='color: var(--red);'>'@'</span> &amp;&amp; c[1] == <span style='color: var(--red);'>'('</span>) {</span><span id='code003-44'><a href='#code003-44' aria-hidden='true'></a>            <span style='color: var(--comment);'>/* Links */</span></span><span id='code003-45'><a href='#code003-45' aria-hidden='true'></a>            </span><span id='code003-46'><a href='#code003-46' aria-hidden='true'></a>        } else if (c[0] == <span style='color: var(--red);'>'!'</span> &amp;&amp; c[1] == <span style='color: var(--red);'>'('</span>) {</span><span id='code003-47'><a href='#code003-47' aria-hidden='true'></a>            <span style='color: var(--comment);'>/* Images */</span></span><span id='code003-48'><a href='#code003-48' aria-hidden='true'></a>            </span><span id='code003-49'><a href='#code003-49' aria-hidden='true'></a>        } else if (c[0] == <span style='color: var(--red);'>'?'</span> &amp;&amp; c[1] == <span style='color: var(--red);'>'('</span>) {</span><span id='code003-50'><a href='#code003-50' aria-hidden='true'></a>            <span style='color: var(--comment);'>/* Explain - Hover over to see expanded text */</span></span><span id='code003-51'><a href='#code003-51' aria-hidden='true'></a>            </span><span id='code003-52'><a href='#code003-52' aria-hidden='true'></a>        } else if (c[0] == <span style='color: var(--red);'>')'</span>) {</span><span id='code003-53'><a href='#code003-53' aria-hidden='true'></a>            <span style='color: var(--comment);'>/* Closing parenthesis can end one of the above ^ */</span></span><span id='code003-54'><a href='#code003-54' aria-hidden='true'></a>            if (paren_stacki &gt; 0) {</span><span id='code003-55'><a href='#code003-55' aria-hidden='true'></a>                Text::Types t = paren_stack[--paren_stacki];</span><span id='code003-56'><a href='#code003-56' aria-hidden='true'></a>                PUSH_TEXT(t, i, 1);</span><span id='code003-57'><a href='#code003-57' aria-hidden='true'></a>            }</span><span id='code003-58'><a href='#code003-58' aria-hidden='true'></a>            break;</span><span id='code003-59'><a href='#code003-59' aria-hidden='true'></a>        } else if (c[0] == <span style='color: var(--red);'>'\\'</span>) {</span><span id='code003-60'><a href='#code003-60' aria-hidden='true'></a>            <span style='color: var(--comment);'>/* Backslash ignores next formatting char */</span></span><span id='code003-61'><a href='#code003-61' aria-hidden='true'></a>        }</span><span id='code003-62'><a href='#code003-62' aria-hidden='true'></a>    } <span style='color: var(--comment);'>/* end str_iter */</span></span><span id='code003-63'><a href='#code003-63' aria-hidden='true'></a>    ASSERTM(pre == &amp;pre_filler || pre-&gt;type != Text::NIL, <span style='color: var(--red);'>"Must not leave NIL nodes in Text linked-list!"</span>);</span><span id='code003-64'><a href='#code003-64' aria-hidden='true'></a>}</span></pre></code>
<p>
I have been leaving out the details inside the if statements in the parsing, but you can see the full details <a href='https://github.com/dev-dwarf/dev-dwarf.github.io/blob/main/static-site-gen/md_to_html.cpp'>here</a>. The insides are mostly just small amounts of parsing text and then some macros for pushing new <code>Block</code> or <code>Text</code> nodes onto linked lists. You might notice in the above parsing some departures from Markdown, such as <code><a href='link'>text</a></code> to notate a link, instead of a <code>[text](link)</code> pair.
</p>
<hr>

<h2 id='compile'>
 Render as HTML
</h2>
<p>
As a basic example of what we have so far, parsing the following:
</p>
<code id='code004'><pre>
<span id='code004-1'><a href='#code004-1' aria-hidden='true'></a>## Hello</span><span id='code004-2'><a href='#code004-2' aria-hidden='true'></a>It's nice to be **loud**!</span></pre></code>
<p>
Will give this structure:
</p>
<code id='code005'><pre>
<span id='code005-1'><a href='#code005-1' aria-hidden='true'></a>Block(type=Header, num=2, text=[</span><span id='code005-2'><a href='#code005-2' aria-hidden='true'></a>    Text(type=Text, str=<span style='color: var(--red);'>"Hello"</span>)</span><span id='code005-3'><a href='#code005-3' aria-hidden='true'></a>]),</span><span id='code005-4'><a href='#code005-4' aria-hidden='true'></a>Block(type=Paragraph, text=[</span><span id='code005-5'><a href='#code005-5' aria-hidden='true'></a>    Text(type=Text, str=<span style='color: var(--red);'>"It's nice to be "</span>),</span><span id='code005-6'><a href='#code005-6' aria-hidden='true'></a>    Text(type=Bold, str=<span style='color: var(--red);'>"loud"</span>, end=false),</span><span id='code005-7'><a href='#code005-7' aria-hidden='true'></a>    Text(type=Bold, str=<span style='color: var(--red);'>"!"</span>, end=true)</span><span id='code005-8'><a href='#code005-8' aria-hidden='true'></a>])</span></pre></code>
<p>
The desired HTML is something like:
</p>
<code id='html'><pre>
<span id='html-1'><a href='#html-1' aria-hidden='true'></a>&lt;h2&gt;Hello&lt;/h2&gt;</span><span id='html-2'><a href='#html-2' aria-hidden='true'></a>&lt;p&gt;It's nice to be &lt;b&gt;loud&lt;/b&gt;!&lt;/p&gt;</span></pre></code>
<p>
With the above as the goal, it's not hard to imagine rendering the parsed nodes to HTML using a couple loops:
</p>
<code id='code007'><pre>
<span id='code007-1'><a href='#code007-1' aria-hidden='true'></a>StrList render(Arena* arena, Block* root) {</span><span id='code007-2'><a href='#code007-2' aria-hidden='true'></a>    StrList out = {0};</span><span id='code007-3'><a href='#code007-3' aria-hidden='true'></a>    for (Block* b = root; b-&gt;type != Block::NIL; b = b-&gt;next) {</span><span id='code007-4'><a href='#code007-4' aria-hidden='true'></a>        switch (b-&gt;type) {</span><span id='code007-5'><a href='#code007-5' aria-hidden='true'></a>            <span style='color: var(--comment);'>/* Do pre-content tags for Block type. EX: */</span></span><span id='code007-6'><a href='#code007-6' aria-hidden='true'></a>            case Block::ORD_LIST: {</span><span id='code007-7'><a href='#code007-7' aria-hidden='true'></a>                StrList_add(arena, &amp;out, strl(<span style='color: var(--red);'>"&amp;ltol&amp;gt\n"</span>));</span><span id='code007-8'><a href='#code007-8' aria-hidden='true'></a>            } break;</span><span id='code007-9'><a href='#code007-9' aria-hidden='true'></a>        }</span><span id='code007-10'><a href='#code007-10' aria-hidden='true'></a>    </span><span id='code007-11'><a href='#code007-11' aria-hidden='true'></a>        b-&gt;content = render_text(arena, b-&gt;text);</span><span id='code007-12'><a href='#code007-12' aria-hidden='true'></a>        StrList_append(&amp;out, StrList_copy(arena, b-&gt;content));    </span><span id='code007-13'><a href='#code007-13' aria-hidden='true'></a>    </span><span id='code007-14'><a href='#code007-14' aria-hidden='true'></a>        switch (b-&gt;type) {</span><span id='code007-15'><a href='#code007-15' aria-hidden='true'></a>            <span style='color: var(--comment);'>/* Do post-content tags for Block type. EX: */</span></span><span id='code007-16'><a href='#code007-16' aria-hidden='true'></a>            case Block::ORD_LIST: {</span><span id='code007-17'><a href='#code007-17' aria-hidden='true'></a>                StrList_add(arena, &amp;out, strl(<span style='color: var(--red);'>"\n&amp;lt/ol&amp;gt\n"</span>));</span><span id='code007-18'><a href='#code007-18' aria-hidden='true'></a>            } break;                    </span><span id='code007-19'><a href='#code007-19' aria-hidden='true'></a>        }</span><span id='code007-20'><a href='#code007-20' aria-hidden='true'></a>    }</span><span id='code007-21'><a href='#code007-21' aria-hidden='true'></a>    return out;</span><span id='code007-22'><a href='#code007-22' aria-hidden='true'></a>}</span><span id='code007-23'><a href='#code007-23' aria-hidden='true'></a></span><span id='code007-24'><a href='#code007-24' aria-hidden='true'></a>StrList render_text(Arena* arena, Text* root) {</span><span id='code007-25'><a href='#code007-25' aria-hidden='true'></a>    StrList out = {0};</span><span id='code007-26'><a href='#code007-26' aria-hidden='true'></a>    Text prev_filler = {root, Text::NIL, 0};</span><span id='code007-27'><a href='#code007-27' aria-hidden='true'></a>    for (Text* t = root, *prev = &amp;prev_filler; t-&gt;type != Text::NIL; prev = t, t = t-&gt;next) {</span><span id='code007-28'><a href='#code007-28' aria-hidden='true'></a>        switch (t-&gt;type) {</span><span id='code007-29'><a href='#code007-29' aria-hidden='true'></a>            <span style='color: var(--comment);'>/* Add start or end tags based on t-&gt;end. EX: */</span></span><span id='code007-30'><a href='#code007-30' aria-hidden='true'></a>            case Text::BOLD: {</span><span id='code007-31'><a href='#code007-31' aria-hidden='true'></a>                str s[2] = {strl(<span style='color: var(--red);'>"&amp;ltb&amp;gt"</span>), strl(<span style='color: var(--red);'>"&amp;lt/b&amp;gt"</span>)};</span><span id='code007-32'><a href='#code007-32' aria-hidden='true'></a>                StrList_add(arena, &amp;out, s[t-&gt;end]);</span><span id='code007-33'><a href='#code007-33' aria-hidden='true'></a>                StrList_add(arena, &amp;out, t-&gt;text);</span><span id='code007-34'><a href='#code007-34' aria-hidden='true'></a>            } break;</span><span id='code007-35'><a href='#code007-35' aria-hidden='true'></a>        }</span><span id='code007-36'><a href='#code007-36' aria-hidden='true'></a>    }</span><span id='code007-37'><a href='#code007-37' aria-hidden='true'></a>    return out;</span><span id='code007-38'><a href='#code007-38' aria-hidden='true'></a>}</span></pre></code>

<hr>

<h2 id='generate'>
 Generating the Site
</h2>
<p>
The markdown compiler is a good step, but it needs to be told what to compile, and the results are still missing necessary HTML boilerplate. For my site I decided to have a <code>src</code> folder for the markdown contents of my articles, and then compile everything to a <code>deploy</code> folder containing the generated HTML and other assets:
</p>
<code id='code008'><pre>
<span id='code008-1'><a href='#code008-1' aria-hidden='true'></a>- dev-dwarf.github.io</span><span id='code008-2'><a href='#code008-2' aria-hidden='true'></a>    - src</span><span id='code008-3'><a href='#code008-3' aria-hidden='true'></a>        foo.md</span><span id='code008-4'><a href='#code008-4' aria-hidden='true'></a>        etc...</span><span id='code008-5'><a href='#code008-5' aria-hidden='true'></a>    - deploy</span><span id='code008-6'><a href='#code008-6' aria-hidden='true'></a>        foo.html</span><span id='code008-7'><a href='#code008-7' aria-hidden='true'></a>        etc...</span></pre></code>
<p>
I started a new file to drive this process. First I defined some structs to store data for each page, and help me manage lists of pages:
</p>
<code id='code009'><pre>
<span id='code009-1'><a href='#code009-1' aria-hidden='true'></a><span style='color: var(--comment);'>/* site.h */</span></span><span id='code009-2'><a href='#code009-2' aria-hidden='true'></a>struct Page {</span><span id='code009-3'><a href='#code009-3' aria-hidden='true'></a>    Page *next; </span><span id='code009-4'><a href='#code009-4' aria-hidden='true'></a>    str filename;</span><span id='code009-5'><a href='#code009-5' aria-hidden='true'></a>    str base_href;</span><span id='code009-6'><a href='#code009-6' aria-hidden='true'></a>    StrList base_dir;</span><span id='code009-7'><a href='#code009-7' aria-hidden='true'></a>    u64 created_time;</span><span id='code009-8'><a href='#code009-8' aria-hidden='true'></a>    u64 modified_time;</span><span id='code009-9'><a href='#code009-9' aria-hidden='true'></a>    str title;</span><span id='code009-10'><a href='#code009-10' aria-hidden='true'></a>    str content;</span><span id='code009-11'><a href='#code009-11' aria-hidden='true'></a>    enum Types {</span><span id='code009-12'><a href='#code009-12' aria-hidden='true'></a>        DEFAULT,</span><span id='code009-13'><a href='#code009-13' aria-hidden='true'></a>        <span style='color: var(--comment);'>/* don't worry about the other types for now */</span></span><span id='code009-14'><a href='#code009-14' aria-hidden='true'></a>    } type;</span><span id='code009-15'><a href='#code009-15' aria-hidden='true'></a>};</span><span id='code009-16'><a href='#code009-16' aria-hidden='true'></a>struct PageList {</span><span id='code009-17'><a href='#code009-17' aria-hidden='true'></a>    Page *first;</span><span id='code009-18'><a href='#code009-18' aria-hidden='true'></a>    Page *last;</span><span id='code009-19'><a href='#code009-19' aria-hidden='true'></a>    u64 count;</span><span id='code009-20'><a href='#code009-20' aria-hidden='true'></a>};</span></pre></code>
<p>
Then there is a main loop that goes something like:
</p>
<code id='code010'><pre>
<span id='code010-1'><a href='#code010-1' aria-hidden='true'></a>global StrList dir;</span><span id='code010-2'><a href='#code010-2' aria-hidden='true'></a>int main() {</span><span id='code010-3'><a href='#code010-3' aria-hidden='true'></a>    Arena *longa = Arena_create_default();</span><span id='code010-4'><a href='#code010-4' aria-hidden='true'></a>    Arena *tempa = Arena_create_default();</span><span id='code010-5'><a href='#code010-5' aria-hidden='true'></a></span><span id='code010-6'><a href='#code010-6' aria-hidden='true'></a>    <span style='color: var(--comment);'>/* ... set dir to src directory */</span></span><span id='code010-7'><a href='#code010-7' aria-hidden='true'></a>    </span><span id='code010-8'><a href='#code010-8' aria-hidden='true'></a>    PageList allPages = get_pages_in_dir(longa, Page::DEFAULT);</span><span id='code010-9'><a href='#code010-9' aria-hidden='true'></a></span><span id='code010-10'><a href='#code010-10' aria-hidden='true'></a>    for (Page *n = allPages.first; n != 0; n = n-&gt;next) {</span><span id='code010-11'><a href='#code010-11' aria-hidden='true'></a>        compile_page(longa, tempa, n);</span><span id='code010-12'><a href='#code010-12' aria-hidden='true'></a>        Arena_reset_all(tempa);</span><span id='code010-13'><a href='#code010-13' aria-hidden='true'></a>    }</span><span id='code010-14'><a href='#code010-14' aria-hidden='true'></a>}</span></pre></code>
<p>
The <code>global StrList dir</code> holds the current directory/file. It's convenient to have it as a list so that I can pop off or switch out nodes to change the targeted file or directory. <code>get_pages_in_dir</code> just uses filesystem calls to make a list of markdown files in the <code>src</code> folder. <code>compile_page</code> loads the raw markdown, compiles it, and adds some enclosing HTML to the front and back. Finally it's written out to the equivalent HTML file in the <code>deploy</code> folder:
</p>
<code id='code011'><pre>
<span id='code011-1'><a href='#code011-1' aria-hidden='true'></a>void compile_page(Arena *longa, Arena *tempa, Page *page) {</span><span id='code011-2'><a href='#code011-2' aria-hidden='true'></a>    StrList_append(&amp;dir, page-&gt;base_dir);</span><span id='code011-3'><a href='#code011-3' aria-hidden='true'></a>        </span><span id='code011-4'><a href='#code011-4' aria-hidden='true'></a>    filename.str = page-&gt;filename;</span><span id='code011-5'><a href='#code011-5' aria-hidden='true'></a>    StrList_add_node(&amp;dir, &amp;filename);</span><span id='code011-6'><a href='#code011-6' aria-hidden='true'></a>    switch_to_dir(&amp;src);</span><span id='code011-7'><a href='#code011-7' aria-hidden='true'></a>    page-&gt;content = win32_load_entire_file(tempa, build_dir(tempa));</span><span id='code011-8'><a href='#code011-8' aria-hidden='true'></a>    StrList_pop_node(&amp;dir);</span><span id='code011-9'><a href='#code011-9' aria-hidden='true'></a></span><span id='code011-10'><a href='#code011-10' aria-hidden='true'></a>    filename.str = str_concat(tempa, str_cut(page-&gt;filename, 3), strl(<span style='color: var(--red);'>"html\0"</span>));</span><span id='code011-11'><a href='#code011-11' aria-hidden='true'></a>    StrList_add_node(&amp;dir, &amp;filename);</span><span id='code011-12'><a href='#code011-12' aria-hidden='true'></a></span><span id='code011-13'><a href='#code011-13' aria-hidden='true'></a>    StrList html = {0};</span><span id='code011-14'><a href='#code011-14' aria-hidden='true'></a>    StrList_add(tempa, &amp;html, HEADER);</span><span id='code011-15'><a href='#code011-15' aria-hidden='true'></a>    StrList_add(tempa, &amp;html, strl(<span style='color: var(--red);'>"\t&lt;title&gt;LCF/DD:"</span>));</span><span id='code011-16'><a href='#code011-16' aria-hidden='true'></a>    StrList_add(tempa, &amp;html, page-&gt;title);</span><span id='code011-17'><a href='#code011-17' aria-hidden='true'></a>    StrList_add(tempa, &amp;html, strl(<span style='color: var(--red);'>"&lt;/title&gt;\n"</span>));</span><span id='code011-18'><a href='#code011-18' aria-hidden='true'></a></span><span id='code011-19'><a href='#code011-19' aria-hidden='true'></a>    Block* blocks = parse(tempa, page-&gt;content);</span><span id='code011-20'><a href='#code011-20' aria-hidden='true'></a>    StrList md = render(tempa, blocks);</span><span id='code011-21'><a href='#code011-21' aria-hidden='true'></a>    StrList_append(&amp;html, md);</span><span id='code011-22'><a href='#code011-22' aria-hidden='true'></a>    </span><span id='code011-23'><a href='#code011-23' aria-hidden='true'></a>    StrList_add(tempa, &amp;html, FOOTER);</span><span id='code011-24'><a href='#code011-24' aria-hidden='true'></a></span><span id='code011-25'><a href='#code011-25' aria-hidden='true'></a>    switch_to_dir(&amp;deploy);</span><span id='code011-26'><a href='#code011-26' aria-hidden='true'></a>    win32_write_file(build_dir(tempa).str, html);</span><span id='code011-27'><a href='#code011-27' aria-hidden='true'></a></span><span id='code011-28'><a href='#code011-28' aria-hidden='true'></a>    page-&gt;content = str_EMPTY; <span style='color: var(--comment);'>/* clear this because it was on the temp arena */</span></span><span id='code011-29'><a href='#code011-29' aria-hidden='true'></a>    StrList_pop_node(&amp;dir);</span><span id='code011-30'><a href='#code011-30' aria-hidden='true'></a>    StrList_pop(&amp;dir, page-&gt;base_dir.count);</span><span id='code011-31'><a href='#code011-31' aria-hidden='true'></a>}</span></pre></code>
<p>
And that's pretty much it for a heavily-idealized version of my static site generator! The actual thing can be found <a href='https://github.com/dev-dwarf/dev-dwarf.github.io'>on GitHub</a>. You may have noticed an unused type field for pages; the real version of the generator has <code>ARTICLE</code> pages and an <code>INDEX</code> page. <code>ARTICLE</code>s have slightly different HTML generated, and the <code>INDEX</code> gets a list of links to articles appended to it. I don't think it's worth writing about these yet as they are very hacked in and I want to change that system soon! However I am pleased with how easy it is to quickly hack in features like those given what I have described here as a base.
</p>
<hr>

<h2 id='conc'>
 Conclusion
</h2>
<p>
Overall I'm pretty happy with the results of this project so far. The up-front time investment was a bit more than using Jekyll (about 4-days of hacking and writing), but for it I have a small, fast, and extendable static site generator tailored to my needs. The current version is ~700 lines of C-like C++, well under the 1000 LOC goal. I already hacked in some basic features to write this article, but I'd like to rework these soon. In addition, there's quite a few things I'd like to add:
</p>
<ol>
<li> Generate an index/section list for articles.</li>
<li> Generate an RSS feed from recent articles.</li>
<li> After the first compile of each page, run in the background checking for changes and compile files automatically. Right now I manually run <code>site.exe</code> to see my changes each time, but it would help my flow if that was taken care of for me.</li>
<li> Introduce some sort of templating/custom generation for individual pages. I <b>abhor</b> how most generators handle this sort of feature so I'm excited to look for a unique approach. I'd prefer something where I can easily hack in new templates in C++ instead of using some bogus templating language.</li>
<li> Additional miscellaneous features like captions for images, subsections, and asides/expandable text. </li>
</ol>
<p>
I should also mention that although the source code for the markdown compiler and my site are on github, they can't be run as is without <a href='https://github.com/dev-dwarf/lcf'>lcf</a>, my personal library of C code. 
</p>
<hr><p class='centert'> Feel free to message me with any comments about this article! <br> Email: <code>contact@loganforman.com</code> </p></main>
</div>
</body>
<div>
<hr>
<nav>
<table class='w33 left'><tr>
<td><a href='/index.html'>home</a></td>
<td><a href='/projects.html'>projects</a></td>
<td><a href='/writing.html'>writing</a></td>
<td><a style='text-decoration-color: #EE802F !important' href='/rss.xml'>rss</a></td>
<td class='light'><a class='light' onClick='toggleNight()'>light</a></td>
<td class='night'><a class='night' onClick='toggleNight()'>night</a></td>
</tr></table>
<table class='w33 right'><tr>
<td><a href='https://github.com/dev-dwarf'>github</a></td>
<td><a href='https://twitter.com/dev_dwarf'>twitter</a></td>
<td><a href='https://bsky.app/profile/dev-dwarf.itch.io'>bluesky</a></td>
<td><a href='https://store.steampowered.com/developer/dd'>steam</a></td>
<td><a href='https://dev-dwarf.itch.io'>itch.io</a></td>
</tr></table>
<p><br><br><br></p>
</nav>
</div>
</html>
